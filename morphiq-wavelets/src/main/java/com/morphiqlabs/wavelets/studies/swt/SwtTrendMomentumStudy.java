package com.morphiqlabs.wavelets.studies.swt;

import com.morphiqlabs.wavelet.api.TransformType;
import com.morphiqlabs.wavelet.api.WaveletName;
import com.morphiqlabs.wavelet.api.WaveletRegistry;
import com.morphiqlabs.wavelets.core.Thresholds;
import com.morphiqlabs.wavelets.core.VectorWaveSwtAdapter;
import com.motivewave.platform.sdk.common.*;
import com.motivewave.platform.sdk.common.desc.*;
import com.motivewave.platform.sdk.draw.Marker;
import com.motivewave.platform.sdk.study.Plot;
import com.motivewave.platform.sdk.study.Study;
import com.motivewave.platform.sdk.study.StudyHeader;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.awt.*;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * SWT Trend + Momentum Study - Advanced trend following with momentum confirmation
 *
 * This study implements a sophisticated trend-following system using the Stationary Wavelet Transform
 * (SWT/MODWT) with momentum confirmation. Key features include:
 *
 * - **Trend Extraction**: Uses wavelet approximation (A_J) to identify the dominant trend
 * - **Momentum Calculation**: Aggregates high-frequency detail coefficients (D1, D2) for momentum
 * - **Adaptive Denoising**: BayesShrink thresholding removes noise while preserving signal features
 * - **Auto-Windowing**: Automatically calculates optimal window size based on wavelet properties
 * - **Signal Generation**: Combines trend slope and momentum for high-probability trade signals
 *
 * Technical Details:
 * - Uses undecimated (redundant) wavelet transform for shift-invariance
 * - Effective support formula: S ≈ 1 + (L-1) * (2^J - 1)
 * - Window size: N = γ * S (γ = safety margin, typically 6.0)
 * - Threshold lookback: M = β * S (β = lookback margin, typically 4.0)
 *
 * @author Morphiq Labs
 */
@StudyHeader(
    namespace = "com.morphiqlabs",
    id = "SWT_TREND_MOMENTUM",
    name = "SWT Trend + Momentum",
    desc = "Advanced trend following with SWT/MODWT and momentum confirmation",
    menu = "MorphIQ Labs",
    overlay = true,
    signals = true,
    requiresBarUpdates = true,
    helpLink = "https://docs.morphiqlabs.com/swt-trend-momentum"
)
public class SwtTrendMomentumStudy extends Study {
    private static final Logger logger = LoggerFactory.getLogger(SwtTrendMomentumStudy.class);

    // =============================================================================================
    // ENUMS - Type-safe keys following best practices
    // =============================================================================================

    /**
     * Value keys for storing calculated values.
     * Using enums provides compile-time type safety and prevents typos.
     */
    public enum Values {
        TREND,        // Wavelet approximation (A_J) - the smoothed trend
        MOMENTUM,     // Momentum oscillator from detail coefficients
        SLOPE         // Rate of change of trend (ΔA_J)
    }

    /**
     * Signal types generated by the study.
     */
    public enum Signals {
        LONG,         // Long entry signal
        SHORT         // Short entry signal
    }

    // =============================================================================================
    // CONSTANTS - Settings keys and configuration
    // =============================================================================================

    // Core wavelet settings
    private static final String WAVELET_TYPE = "waveletType";
    private static final String DECOMPOSITION_LEVELS = "decompositionLevels";
    private static final String USE_DENOISED = "useDenoised";

    // Signal generation settings
    protected static final String MOMENTUM_THRESHOLD = "momentumThreshold";
    private static final String MIN_SLOPE_THRESHOLD = "minSlopeThreshold";
    private static final String MOMENTUM_SMOOTHING = "momentumSmoothing";
    protected static final String ENABLE_SIGNALS = "enableSignals";

    // Window configuration
    private static final String AUTO_WINDOW = "autoWindow";
    private static final String WINDOW_LENGTH = "windowLength";
    private static final String GAMMA_MARGIN = "gammaMargin";

    // Threshold lookback configuration
    private static final String AUTO_THRESH_LOOKBACK = "autoThreshLookback";
    private static final String THRESH_LOOKBACK = "threshLookback";
    private static final String BETA_MARGIN = "betaMargin";


    // Plot and indicator keys
    private static final String MOMENTUM_PLOT = "momentumPlot";
    private static final String MOMENTUM_IND = "momentumInd";

    // =============================================================================================
    // DEFAULTS AND LIMITS
    // =============================================================================================

    // Wavelet decomposition
    private static final int DEFAULT_LEVELS = 4;
    private static final int MIN_LEVELS = 2;
    private static final int MAX_LEVELS = 8;

    // Signal thresholds
    private static final boolean DEFAULT_USE_DENOISED = true;
    private static final double DEFAULT_MOMENTUM_THRESHOLD = 0.1;
    private static final double DEFAULT_MIN_SLOPE = 0.05;  // 0.05 points minimum slope
    private static final double DEFAULT_SMOOTHING = 0.5;   // EMA alpha for momentum

    // Window parameters
    private static final boolean DEFAULT_AUTO_WINDOW = true;
    private static final int DEFAULT_WINDOW = 1024;
    private static final int MIN_WINDOW = 256;
    private static final int MAX_WINDOW = 8192;
    private static final double DEFAULT_GAMMA = 6.0;  // Window = gamma * effective_support

    // Threshold lookback parameters
    private static final boolean DEFAULT_AUTO_THRESH_LOOKBACK = true;
    private static final int DEFAULT_THRESH_LOOKBACK = 1024;
    private static final int MIN_THRESH_LOOKBACK = 256;
    private static final int MAX_THRESH_LOOKBACK = 4096;
    private static final double DEFAULT_BETA = 4.0;  // Lookback = beta * effective_support

    // Momentum calculation
    private static final int MOMENTUM_LEVELS = 2;  // Use D1 and D2 for momentum

    private static final double DEFAULT_LINEAR_FACTOR = 100.0;  // For LINEAR scaling
    private static final double DEFAULT_SQRT_FACTOR = 10.0;    // For SQRT scaling
    private static final double DEFAULT_LOG_FACTOR = 5.0;      // For LOG scaling

    // =============================================================================================
    // STATE MANAGEMENT
    // =============================================================================================

    // Wavelet adapter
    private VectorWaveSwtAdapter swtAdapter;


    // Momentum state
    private Double smoothedMomentum = null;  // null = uninitialized, enables proper EMA initialization
    
    // Track last marker indices to prevent duplicates
    private int lastLongMarkerIndex = -1;
    private int lastShortMarkerIndex = -1;

    // Cache for wavelet type
    private String lastWaveletType = null;

    // =============================================================================================
    // INITIALIZATION - Following Tab → Group → Row pattern
    // =============================================================================================

    /**
     * Initializes the study's settings, plots, and indicators.
     * This method is called once when the study is first created. It defines the user interface
     * for the study's settings, including input selection, wavelet configuration, signal parameters,
     * and display options.
     *
     * @param defaults Default values provided by the MotiveWave platform.
     */
    @Override
    public void initialize(Defaults defaults) {
        logger.debug("Initializing SWT Trend + Momentum Study");

        // Create Settings Descriptor
        var sd = createSD();

        // ---- General Tab ----
        var generalTab = sd.addTab("General");

        // Input configuration
        var inputsGroup = generalTab.addGroup("Inputs");
        inputsGroup.addRow(new InputDescriptor(Inputs.INPUT, "Input", Enums.BarInput.CLOSE));

        // Wavelet configuration
        var waveletGroup = generalTab.addGroup("Wavelet Transform");
        waveletGroup.addRow(
            new DiscreteDescriptor(WAVELET_TYPE, "Wavelet Type", "DB4",
                createSWTWaveletOptions())
        );
        waveletGroup.addRow(
            new IntegerDescriptor(DECOMPOSITION_LEVELS, "Decomposition Levels",
                DEFAULT_LEVELS, MIN_LEVELS, MAX_LEVELS, 1)
        );
        waveletGroup.addRow(
            new BooleanDescriptor(USE_DENOISED, "Use Denoised Signal", DEFAULT_USE_DENOISED)
        );

        // Window configuration
        var windowGroup = generalTab.addGroup("Window Settings");
        windowGroup.addRow(
            new BooleanDescriptor(AUTO_WINDOW, "Auto Window Size", DEFAULT_AUTO_WINDOW)
        );
        windowGroup.addRow(
            new DoubleDescriptor(GAMMA_MARGIN, "Auto Window Margin (γ)",
                DEFAULT_GAMMA, 2.0, 12.0, 0.5)
        );
        windowGroup.addRow(
            new IntegerDescriptor(WINDOW_LENGTH, "Manual Window (bars)",
                DEFAULT_WINDOW, MIN_WINDOW, MAX_WINDOW, 64)
        );

        // Enable manual window only when auto is disabled
        sd.addDependency(new EnabledDependency(false, AUTO_WINDOW, WINDOW_LENGTH));
        sd.addDependency(new EnabledDependency(true, AUTO_WINDOW, GAMMA_MARGIN));

        // ---- Advanced Tab ----
        var advancedTab = sd.addTab("Advanced");

        // Signal configuration
        var signalGroup = advancedTab.addGroup("Signal Generation");
        signalGroup.addRow(
            new BooleanDescriptor(ENABLE_SIGNALS, "Enable Trading Signals", true)
        );
        signalGroup.addRow(
            new DoubleDescriptor(MOMENTUM_THRESHOLD, "Momentum Threshold",
                DEFAULT_MOMENTUM_THRESHOLD, 0.0, 10.0, 0.01)
        );
        signalGroup.addRow(
            new DoubleDescriptor(MIN_SLOPE_THRESHOLD, "Min Slope (Points)",
                DEFAULT_MIN_SLOPE, 0.0, 1.0, 0.01)
        );
        signalGroup.addRow(
            new DoubleDescriptor(MOMENTUM_SMOOTHING, "Momentum Smoothing (α)",
                DEFAULT_SMOOTHING, 0.1, 0.9, 0.05)
        );

        // Enable signal settings only when signals are enabled
        sd.addDependency(new EnabledDependency(ENABLE_SIGNALS,
            MOMENTUM_THRESHOLD, MIN_SLOPE_THRESHOLD, MOMENTUM_SMOOTHING));

        // Threshold lookback configuration
        var thresholdGroup = advancedTab.addGroup("Denoising Configuration");
        thresholdGroup.addRow(
            new BooleanDescriptor(AUTO_THRESH_LOOKBACK, "Auto Lookback", DEFAULT_AUTO_THRESH_LOOKBACK)
        );
        thresholdGroup.addRow(
            new DoubleDescriptor(BETA_MARGIN, "Auto Lookback Margin (β)",
                DEFAULT_BETA, 2.0, 12.0, 0.5)
        );
        thresholdGroup.addRow(
            new IntegerDescriptor(THRESH_LOOKBACK, "Manual Lookback (bars)",
                DEFAULT_THRESH_LOOKBACK, MIN_THRESH_LOOKBACK, MAX_THRESH_LOOKBACK, 64)
        );

        // Enable manual lookback only when auto is disabled
        sd.addDependency(new EnabledDependency(false, AUTO_THRESH_LOOKBACK, THRESH_LOOKBACK));
        sd.addDependency(new EnabledDependency(true, AUTO_THRESH_LOOKBACK, BETA_MARGIN));

        // ---- Display Tab ----
        var displayTab = sd.addTab("Display");

        // Path configuration
        var pathsGroup = displayTab.addGroup("Lines");
        // Store the blue color to ensure path and indicator use exact same color
        Color trendColor = defaults.getBlue();
        pathsGroup.addRow(
            new PathDescriptor(Inputs.PATH, "Trend Line",
                trendColor, 2.0f, null, true, true, true)
        );
        pathsGroup.addRow(
            new PathDescriptor(Inputs.PATH2, "Momentum",
                Color.CYAN, 1.5f, null, true, true, false)
        );
        // Slope path removed - slope is calculated internally for signals but not displayed

        // Indicator configuration
        var indicatorsGroup = displayTab.addGroup("Indicators");
        indicatorsGroup.addRow(
            new IndicatorDescriptor(Inputs.IND, "Trend",
                trendColor,  // bgColor (background color) - blue background
                Color.WHITE,  // txtColor (text color) - white text
                false,  // showLine
                false,  // enabled by default
                true)   // supportsDisable
        );
        indicatorsGroup.addRow(
            new IndicatorDescriptor(MOMENTUM_IND, "Momentum",
                Color.CYAN,  // bgColor - cyan background
                Color.BLACK,  // txtColor - black text for better contrast
                false,  // showLine
                false,  // enabled by default
                true)   // supportsDisable
        );
        // Slope indicator removed - slope is calculated internally for signals but not displayed

        // Add markers to Display tab
        var markersGroup = displayTab.addGroup("Markers");
        markersGroup.addRow(
            new MarkerDescriptor(Signals.LONG.name(), "Long Signal",
                Enums.MarkerType.TRIANGLE, Enums.Size.MEDIUM,
                defaults.getGreen(), defaults.getLineColor(), true, true)
        );
        markersGroup.addRow(
            new MarkerDescriptor(Signals.SHORT.name(), "Short Signal",
                Enums.MarkerType.TRIANGLE, Enums.Size.MEDIUM,
                defaults.getRed(), defaults.getLineColor(), true, true)
        );

        // Create Runtime Descriptor
        var desc = createRD();

        // Configure label generation
        desc.setLabelSettings(WAVELET_TYPE, DECOMPOSITION_LEVELS);

        // Export values for external access
        desc.exportValue(new ValueDescriptor(Values.TREND, "SWT Trend",
            new String[]{WAVELET_TYPE, DECOMPOSITION_LEVELS}));
        desc.exportValue(new ValueDescriptor(Values.MOMENTUM, "Momentum",
            new String[]{DECOMPOSITION_LEVELS}));
        // Slope is calculated internally for signals but not exported

        // Main plot configuration (overlay on price)
        desc.declarePath(Values.TREND, Inputs.PATH);
        desc.declareIndicator(Values.TREND, Inputs.IND);
        desc.setRangeKeys(Values.TREND);

        // Momentum plot (separate pane)
        Plot momentumPlot = new Plot();
        desc.addPlot(MOMENTUM_PLOT, momentumPlot);
        momentumPlot.setLabelSettings("Momentum");
        momentumPlot.setTabName("Momentum");
        momentumPlot.declarePath(Values.MOMENTUM, Inputs.PATH2);
        // Slope path removed - calculated internally but not displayed
        momentumPlot.declareIndicator(Values.MOMENTUM, MOMENTUM_IND);
        // Slope indicator removed - calculated internally but not displayed
        momentumPlot.setRangeKeys(Values.MOMENTUM);
        momentumPlot.addHorizontalLine(new LineInfo(0.0, null, 1.0f, new float[]{3, 3}));

        // Signal declarations
        desc.declareSignal(Signals.LONG, "Long Signal");
        desc.declareSignal(Signals.SHORT, "Short Signal");

        setRuntimeDescriptor(desc);
    }

    // =============================================================================================
    // LIFECYCLE METHODS
    // =============================================================================================

    /**
     * Called when the study is loaded. Initializes the wavelet adapter and sets the minimum
     * number of bars required for calculation based on the current settings.
     *
     * @param defaults Default values provided by the MotiveWave platform.
     */
    @Override
    public void onLoad(Defaults defaults) {
        try {
            // Initialize wavelet adapter with current settings
            initializeAdapter();

            if (swtAdapter == null) {
                // Try fallback initialization
                swtAdapter = new VectorWaveSwtAdapter(WaveletName.DB4);
                lastWaveletType = "db4";
            }

            // Set minimum bars based on current settings
            int minBars = calculateCurrentWindowLength();
            setMinBars(minBars);

            if (logger.isDebugEnabled()) {
                logger.debug("onLoad: Initialized with wavelet={}, minBars={}",
                            lastWaveletType, minBars);
            }

        } catch (Exception e) {
            // Ensure we have at least a basic adapter
            if (swtAdapter == null) {
                swtAdapter = new VectorWaveSwtAdapter(WaveletName.DB4);
                lastWaveletType = "db4";
            }
            setMinBars(DEFAULT_WINDOW);
            if (logger.isDebugEnabled()) {
                logger.debug("onLoad: Error during initialization, using defaults", e);
            }
        }
    }

    /**
     * Called when the study's settings are updated by the user.
     * This method clears all cached state, forces a re-initialization of the wavelet adapter,
     * and marks all bars for recalculation to ensure the chart reflects the new settings.
     *
     * @param ctx The data context.
     */
    @Override
    public void onSettingsUpdated(DataContext ctx) {
        logger.debug("onSettingsUpdated: Clearing state for recalculation");

        // Clear cached state and force adapter reinitialization
        clearState();

        // Force wavelet type check on next calculation
        lastWaveletType = null;
        swtAdapter = null;

        // Update minimum bars
        setMinBars(calculateCurrentWindowLength());

        // Mark all bars for recalculation and clear values to force range recalculation
        DataSeries series = ctx.getDataSeries();
        if (series != null) {
            // Clear all calculated values to ensure complete recalculation and range update
            for (int i = 0; i < series.size(); i++) {
                series.setComplete(i, false);
                // Clear all values - this forces MotiveWave to recalculate plot ranges
                series.setDouble(i, Values.TREND, null);
                series.setDouble(i, Values.MOMENTUM, null);
                series.setDouble(i, Values.SLOPE, null);
            }
        }

        // Call parent implementation
        super.onSettingsUpdated(ctx);
    }

    /**
     * Clears the internal state of the study. This includes resetting the wavelet adapter,
     * momentum smoothing state, and cached wavelet type.
     */
    @Override
    public void clearState() {
        if (logger.isDebugEnabled()) {
            logger.debug("clearState: Resetting internal state");
        }
        super.clearState();

        // Reset adapter and state
        swtAdapter = null;
        smoothedMomentum = null;
        lastWaveletType = null;
        
        // Reset marker tracking
        lastLongMarkerIndex = -1;
        lastShortMarkerIndex = -1;
    }

    /**
     * Returns the minimum number of bars required for the study to perform its calculations.
     * This is determined by the configured window length plus a small buffer for slope calculation.
     *
     * @return The minimum number of bars required.
     */
    @Override
    public int getMinBars() {
        // Return minimum bars needed based on window configuration
        return calculateCurrentWindowLength() + 10;  // Add buffer for slope calculation
    }

    // =============================================================================================
    // CALCULATION - Core wavelet processing
    // =============================================================================================

    /**
     * Main calculation entry point. Iterates through all data bars and calls the
     * {@link #calculate(int, DataContext)} method for any bars that have not yet been completed.
     *
     * @param ctx The data context containing the data series.
     */
    @Override
    protected void calculateValues(DataContext ctx) {
        DataSeries series = ctx.getDataSeries();
        if (series == null) return;

        int size = series.size();
        if (size == 0) return;

        // Find the first incomplete bar to start processing
        int startIndex = size - 1;
        for (int i = size - 1; i >= 0; i--) {
            if (!series.isComplete(i)) {
                startIndex = i;
            } else {
                // Found a complete bar, can stop looking backwards
                break;
            }
        }

        // Process only incomplete bars starting from the first one found
        for (int i = startIndex; i < size; i++) {
            if (!series.isComplete(i)) {
                calculate(i, ctx);
            }
        }
    }

    /**
     * Performs the core wavelet calculation for a single data bar at the given index.
     * This method handles data windowing, SWT transformation, denoising, trend and momentum
     * calculation, and signal generation.
     *
     * @param index The index of the data bar to calculate.
     * @param ctx   The data context.
     */
    @Override
    protected void calculate(int index, DataContext ctx) {
        DataSeries series = ctx.getDataSeries();
        if (series == null || series.size() == 0) {
            return;
        }

        // Skip if already complete (avoid recalculation)
        if (series.isComplete(index)) {
            return;
        }

        // Check if wavelet type has changed
        String currentWaveletType = getSettings().getString(WAVELET_TYPE, "db4");
        if (!currentWaveletType.equals(lastWaveletType)) {
            // Wavelet type changed, force complete reinitialization
            logger.info("Wavelet type changed from {} to {}, forcing reinitialization",
                       lastWaveletType, currentWaveletType);
            swtAdapter = null;  // Clear old adapter
            lastWaveletType = null;  // Force recreation
            smoothedMomentum = null;  // Reset momentum state
            initializeAdapter();
        }

        // Ensure adapter is initialized
        if (swtAdapter == null) {
            initializeAdapter();
            if (swtAdapter == null) {
                // Fallback initialization
                swtAdapter = new VectorWaveSwtAdapter(WaveletName.DB4);
                lastWaveletType = "db4";
            }
        }

        // Get current settings
        int levels = getSettings().getInteger(DECOMPOSITION_LEVELS, DEFAULT_LEVELS);
        boolean useDenoised = getSettings().getBoolean(USE_DENOISED, DEFAULT_USE_DENOISED);
        boolean enableSignals = getSettings().getBoolean(ENABLE_SIGNALS, true);
        Object input = getSettings().getInput(Inputs.INPUT);

        // Calculate window parameters
        int windowLength = calculateCurrentWindowLength();
        int threshLookback = calculateCurrentThresholdLookback(levels);

        // Check if we have enough data
        if (index < windowLength - 1) {
            clearValues(series, index);
            return;
        }

        // Get sliding window of data
        double[] data = getWindowData(series, index, windowLength, input);
        if (data == null || data.length < windowLength) {
            clearValues(series, index);
            return;
        }

        // Log parameters only once
        if (index == windowLength - 1 && logger.isDebugEnabled()) {
            logCalculationParameters(levels, windowLength, threshLookback);
        }

        try {
            // Perform SWT/MODWT transform
            VectorWaveSwtAdapter.SwtResult swtResult = swtAdapter.transform(data, levels);
            if (swtResult == null) {
                clearValues(series, index);
                return;
            }

            // Log transform details on first few bars for debugging
            if (index < windowLength + 5 && logger.isDebugEnabled()) {
                double[] approx = swtResult.getApproximation();
                logger.debug("Transform at index {} with {}: approx length={}, last value={}",
                           index, swtResult.getWaveletName(),
                           approx != null ? approx.length : 0,
                           approx != null && approx.length > 0 ? approx[approx.length - 1] : "null");
            }

            // Calculate momentum from detail coefficients
            double rawMom = calculateRawMomentum(swtResult);
            double momentum = smoothMomentum(rawMom);
            series.setDouble(index, Values.MOMENTUM, momentum);

            // Apply denoising if enabled
            if (useDenoised) {
                applyBayesShrinkDenoising(swtResult, threshLookback);
            }

            // Extract trend value
            double currentTrend = extractTrendValue(swtResult, useDenoised, levels);
            series.setDouble(index, Values.TREND, currentTrend);

            // Calculate slope
            double slope = 0.0;
            if (index > 0) {
                Double prevTrend = series.getDouble(index - 1, Values.TREND);
                if (prevTrend != null) {
                    slope = currentTrend - prevTrend;
                    series.setDouble(index, Values.SLOPE, slope);

                    // Generate signals if enabled
                    if (enableSignals) {
                        generateSignals(ctx, series, index, momentum, slope);
                    }
                }
            }

            // Mark as complete
            series.setComplete(index);

        } catch (Exception e) {
            logger.error("calculate: Error at index {}", index, e);
            clearValues(series, index);
        }
    }

    /**
     * Clears all calculated values (Trend, Momentum, Slope) for a given bar index.
     *
     * @param series The data series.
     * @param index  The index of the bar to clear.
     */
    private void clearValues(DataSeries series, int index) {
        series.setDouble(index, Values.TREND, null);
        series.setDouble(index, Values.MOMENTUM, null);
        series.setDouble(index, Values.SLOPE, null);
    }

    /**
     * Extracts a sliding window of input data from the data series.
     *
     * @param series       The data series.
     * @param index        The current bar index (end of the window).
     * @param windowLength The length of the window to extract.
     * @param input        The input source (e.g., Close, Open).
     * @return An array of doubles representing the data window, or null if data is insufficient.
     */
    private double[] getWindowData(DataSeries series, int index, int windowLength, Object input) {
        if (series == null || windowLength <= 0) {
            return null;
        }

        double[] window = new double[windowLength];
        int start = index - windowLength + 1;

        // Track if we have valid data
        boolean hasValidData = false;

        for (int i = 0; i < windowLength; i++) {
            int dataIndex = start + i;
            if (dataIndex < 0 || dataIndex >= series.size()) {
                // Use first/last available value for padding
                window[i] = (dataIndex < 0) ? series.getClose(0) : series.getClose(series.size() - 1);
                continue;
            }

            Double value = series.getDouble(dataIndex, input);
            if (value != null) {
                window[i] = value;
                hasValidData = true;
            } else {
                // Fallback to close price
                window[i] = series.getClose(dataIndex);
                if (window[i] != 0.0) {
                    hasValidData = true;
                }
            }
        }

        if (!hasValidData) {
            return null;
        }

        return window;
    }

    /**
     * Calculates the raw momentum value from the high-frequency detail coefficients (D1, D2)
     * of the SWT result. It sums the last coefficient from each of these levels.
     *
     * @param swtResult The result of the Stationary Wavelet Transform.
     * @return The calculated raw momentum value.
     */
    private double calculateRawMomentum(VectorWaveSwtAdapter.SwtResult swtResult) {
        int levelsToUse = Math.min(MOMENTUM_LEVELS, swtResult.getLevels());
        double momentum = 0.0;

        // Sum last coefficients from D1 and D2 (high-frequency components)
        for (int level = 1; level <= levelsToUse; level++) {
            double[] detail = swtResult.getDetail(level);
            if (detail != null && detail.length > 0) {
                momentum += detail[detail.length - 1];
            }
        }

        return momentum;
    }

    /**
     * Applies exponential smoothing to the raw momentum value to produce a smoother oscillator.
     *
     * @param newValue The new raw momentum value to be smoothed.
     * @return The smoothed momentum value.
     */
    private double smoothMomentum(double newValue) {
        double alpha = getSettings().getDouble(MOMENTUM_SMOOTHING, DEFAULT_SMOOTHING);

        // Initialize on first value
        if (smoothedMomentum == null) {
            smoothedMomentum = newValue;
        } else {
            // EMA formula: smoothed = α * new + (1 - α) * previous
            smoothedMomentum = alpha * newValue + (1.0 - alpha) * smoothedMomentum;
        }

        return smoothedMomentum;
    }

    /**
     * Applies BayesShrink denoising to the detail coefficients of the SWT result.
     * This adaptive thresholding method removes noise while preserving important signal features.
     *
     * @param swtResult The SWT result containing the coefficients to be denoised.
     * @param lookback  The number of recent samples to use for estimating the noise level.
     */
    private void applyBayesShrinkDenoising(VectorWaveSwtAdapter.SwtResult swtResult, int lookback) {
        // Apply threshold to each detail level
        for (int level = 1; level <= swtResult.getLevels(); level++) {
            double[] detail = swtResult.getDetail(level);
            if (detail == null || detail.length == 0) continue;

            // Use last M samples to estimate threshold
            int m = Math.min(lookback, detail.length);
            int start = detail.length - m;
            double[] tail = new double[m];
            System.arraycopy(detail, start, tail, 0, m);

            // Calculate BayesShrink threshold
            double threshold = Thresholds.calculateThreshold(
                tail, Thresholds.ThresholdMethod.BAYES, level);

            // Apply soft thresholding
            swtResult.applyShrinkage(level, threshold, true);
        }
    }

    /**
     * Extracts the final trend value from the SWT result.
     * If denoising is enabled, it reconstructs the signal from the thresholded coefficients.
     * Otherwise, it uses the raw approximation coefficient (A_J).
     *
     * @param swtResult   The result of the SWT.
     * @param useDenoised Whether to use the denoised signal.
     * @param levels      The number of decomposition levels.
     * @return The extracted trend value.
     */
    private double extractTrendValue(VectorWaveSwtAdapter.SwtResult swtResult,
                                     boolean useDenoised, int levels) {
        if (useDenoised) {
            // Reconstruct denoised signal from thresholded coefficients
            double[] reconstructed = swtResult.reconstruct(levels);
            if (reconstructed != null && reconstructed.length > 0) {
                double value = reconstructed[reconstructed.length - 1];
                if (logger.isTraceEnabled()) {
                    logger.trace("Denoised trend value: {}", value);
                }
                return value;
            }
        } else {
            // Use raw approximation coefficients
            double[] approx = swtResult.getApproximation();
            if (approx != null && approx.length > 0) {
                double value = approx[approx.length - 1];
                // Log the actual approximation value being used
                if (logger.isDebugEnabled()) {
                    logger.debug("Extracted trend from {}: A[{}]={}, first 3=[{}, {}, {}]",
                               swtResult.getWaveletName(), approx.length - 1, value,
                               approx.length > 0 ? approx[0] : "N/A",
                               approx.length > 1 ? approx[1] : "N/A",
                               approx.length > 2 ? approx[2] : "N/A");
                }
                return value;
            }
        }

        logger.warn("Failed to extract trend value, returning 0.0");
        return 0.0;  // Fallback
    }

    /**
     * Generates trading signals (Long/Short) based on the calculated momentum and trend slope.
     * A signal is generated when momentum and slope agree on the direction and exceed their
     * respective thresholds.
     *
     * @param ctx      The data context.
     * @param series   The data series.
     * @param index    The current bar index.
     * @param momentum The smoothed momentum value.
     * @param slope    The slope of the trend line.
     */
    private void generateSignals(DataContext ctx, DataSeries series, int index,
                                 double momentum, double slope) {
        double momentumThreshold = getSettings().getDouble(MOMENTUM_THRESHOLD, DEFAULT_MOMENTUM_THRESHOLD);
        double minSlope = getSettings().getDouble(MIN_SLOPE_THRESHOLD, DEFAULT_MIN_SLOPE);

        // Long signal: positive momentum and upward slope
        if (momentum > momentumThreshold && slope > minSlope) {
            MarkerInfo marker = getSettings().getMarker(Signals.LONG.name());
            if (marker != null && marker.isEnabled()) {
                // Signal for strategies
                ctx.signal(index, Signals.LONG, "Long Signal", series.getClose(index));
                series.setBoolean(index, Signals.LONG, true);

                // Add visible marker to chart only if we haven't already added one at this index
                if (lastLongMarkerIndex != index) {
                    double price = series.getClose(index);
                    Coordinate coord = new Coordinate(series.getStartTime(index), price);
                    addFigure(new Marker(coord, Enums.Position.BOTTOM, marker));
                    lastLongMarkerIndex = index;
                }
            }
        }

        // Short signal: negative momentum and downward slope
        if (momentum < -momentumThreshold && slope < -minSlope) {
            MarkerInfo marker = getSettings().getMarker(Signals.SHORT.name());
            if (marker != null && marker.isEnabled()) {
                // Signal for strategies
                ctx.signal(index, Signals.SHORT, "Short Signal", series.getClose(index));
                series.setBoolean(index, Signals.SHORT, true);

                // Add visible marker to chart only if we haven't already added one at this index
                if (lastShortMarkerIndex != index) {
                    double price = series.getClose(index);
                    Coordinate coord = new Coordinate(series.getStartTime(index), price);
                    addFigure(new Marker(coord, Enums.Position.TOP, marker));
                    lastShortMarkerIndex = index;
                }
            }
        }
    }

    /**
     * Logs the key calculation parameters for debugging purposes.
     *
     * @param levels         The number of decomposition levels.
     * @param windowLength   The calculated window length.
     * @param threshLookback The calculated threshold lookback period.
     */
    private void logCalculationParameters(int levels, int windowLength, int threshLookback) {
        if (!logger.isDebugEnabled()) return;

        String waveletType = getSettings().getString(WAVELET_TYPE, "db4");
        int filterLength = getFilterLength();
        int support = calculateEffectiveSupport(filterLength, levels);
        boolean useDenoised = getSettings().getBoolean(USE_DENOISED, DEFAULT_USE_DENOISED);

        logger.debug("SWT Parameters: wavelet={}, filterLength={}, levels={}, " +
                    "effectiveSupport={}, window={}, threshLookback={}, denoised={}",
                    waveletType, filterLength, levels, support,
                    windowLength, threshLookback, useDenoised);
    }

    // =============================================================================================
    // WAVELET CONFIGURATION HELPERS
    // =============================================================================================

    /**
     * Initializes or re-initializes the {@link VectorWaveSwtAdapter} based on the
     * currently selected wavelet type in the study settings.
     */
    private void initializeAdapter() {
        String waveletType = getSettings().getString(WAVELET_TYPE, "DB4");

        logger.info("Creating new SWT adapter with wavelet: {} (was: {})",
                   waveletType, lastWaveletType);

        try {
            WaveletName waveletNameEnum = WaveletName.valueOf(waveletType);
            swtAdapter = new VectorWaveSwtAdapter(waveletNameEnum);
            lastWaveletType = waveletType;
            logger.info("Successfully initialized SWT adapter with wavelet: {}", waveletType);
        } catch (IllegalArgumentException e) {
            logger.error("Failed to initialize adapter with invalid wavelet type '{}'. Please select a valid wavelet from the settings. Error: {}", 
                        waveletType, e.getMessage());
            swtAdapter = null;
            lastWaveletType = null;
        }
    }

    /**
     * Gets the filter length for the currently selected wavelet. It first attempts to get the
     * length from the adapter and falls back to a set of known default values if needed.
     *
     * @return The length of the wavelet filter.
     */
    private int getFilterLength() {
        if (swtAdapter != null) {
            try {
                int length = swtAdapter.getFilterLength();
                if (length > 0) return length;
            } catch (Exception e) {
                logger.debug("Could not get filter length from adapter", e);
            }
        }

        // Fallback to known values
        String waveletType = getSettings().getString(WAVELET_TYPE, "db4");
        return switch (waveletType.toLowerCase()) {
            case "haar" -> 2;
            case "db6" -> 12;
            case "db4" -> 8;
            default -> 8;
        };
    }

    /**
     * Calculates the effective support for the undecimated wavelet transform using the formula:
     * Support ≈ 1 + (L - 1) * (2^J - 1), where L is filter length and J is decomposition level.
     *
     * @param filterLength The length of the wavelet filter.
     * @param levels       The number of decomposition levels.
     * @return The calculated effective support size.
     */
    private int calculateEffectiveSupport(int filterLength, int levels) {
        return 1 + (filterLength - 1) * ((1 << levels) - 1);
    }

    /**
     * Calculates the required window length for the analysis. If auto-windowing is enabled,
     * it's determined by the effective support and a gamma margin. Otherwise, it uses the
     * manually configured value.
     *
     * @return The calculated window length in bars.
     */
    private int calculateCurrentWindowLength() {
        Settings settings = getSettings();
        boolean autoWindow = settings.getBoolean(AUTO_WINDOW, DEFAULT_AUTO_WINDOW);

        if (autoWindow) {
            int levels = settings.getInteger(DECOMPOSITION_LEVELS, DEFAULT_LEVELS);
            double gamma = settings.getDouble(GAMMA_MARGIN, DEFAULT_GAMMA);
            int filterLength = getFilterLength();
            int support = calculateEffectiveSupport(filterLength, levels);
            int windowLength = (int) Math.ceil(gamma * support);

            // Round up to nearest 64 for cache efficiency
            windowLength = ((windowLength + 63) / 64) * 64;

            // Clamp to valid range
            return Math.max(MIN_WINDOW, Math.min(MAX_WINDOW, windowLength));
        }

        return settings.getInteger(WINDOW_LENGTH, DEFAULT_WINDOW);
    }

    /**
     * Calculates the lookback period for denoising threshold estimation. If auto-lookback is
     * enabled, it's determined by the effective support and a beta margin. Otherwise, it uses
     * the manually configured value.
     *
     * @param levels The number of decomposition levels.
     * @return The calculated lookback period in bars.
     */
    private int calculateCurrentThresholdLookback(int levels) {
        Settings settings = getSettings();
        boolean autoLookback = settings.getBoolean(AUTO_THRESH_LOOKBACK, DEFAULT_AUTO_THRESH_LOOKBACK);

        if (autoLookback) {
            double beta = settings.getDouble(BETA_MARGIN, DEFAULT_BETA);
            int filterLength = getFilterLength();
            int support = calculateEffectiveSupport(filterLength, levels);
            int lookback = (int) Math.ceil(beta * support);

            // Round up to nearest 64
            lookback = ((lookback + 63) / 64) * 64;

            // Clamp to valid range
            return Math.max(MIN_THRESH_LOOKBACK, Math.min(MAX_THRESH_LOOKBACK, lookback));
        }

        return settings.getInteger(THRESH_LOOKBACK, DEFAULT_THRESH_LOOKBACK);
    }


    // =============================================================================================
    // UI HELPERS
    // =============================================================================================

    /**
     * Creates a list of SWT-compatible wavelets for the UI dropdown menu.
     * It queries the {@link WaveletRegistry} to get only wavelets suitable for the
     * Stationary Wavelet Transform and organizes them by family for a better user experience.
     *
     * @return A list of {@link NVP} objects for use in a dropdown descriptor.
     */
    private List<NVP> createSWTWaveletOptions() {
        List<NVP> options = new ArrayList<>();

        try {
            // Get wavelets specifically compatible with SWT transform
            List<WaveletName> swtWavelets = WaveletRegistry.getWaveletsForTransform(TransformType.SWT);

            // Use the new family-specific API methods for better organization
            // Get wavelets by family and filter for SWT compatibility
            List<WaveletName> daubechiesFamily = WaveletRegistry.getDaubechiesWavelets();
            List<WaveletName> symletFamily = WaveletRegistry.getSymletWavelets();
            List<WaveletName> coifletFamily = WaveletRegistry.getCoifletWavelets();

            // Add wavelets in family groups for better UI organization
            // Start with Haar (simplest) - always compatible with SWT
            if (swtWavelets.contains(WaveletName.HAAR)) {
                options.add(new NVP("Haar", WaveletName.HAAR.name()));
            }

            // Then Daubechies (most common) - only add if SWT compatible
            for (WaveletName wavelet : daubechiesFamily) {
                if (swtWavelets.contains(wavelet)) {
                    options.add(new NVP(wavelet.getDescription(), wavelet.name()));
                }
            }

            // Then Symlets - only add if SWT compatible
            for (WaveletName wavelet : symletFamily) {
                if (swtWavelets.contains(wavelet)) {
                    options.add(new NVP(wavelet.getDescription(), wavelet.name()));
                }
            }

            // Finally Coiflets - only add if SWT compatible
            for (WaveletName wavelet : coifletFamily) {
                if (swtWavelets.contains(wavelet)) {
                    options.add(new NVP(wavelet.getDescription(), wavelet.name()));
                }
            }

            logger.info("Created {} SWT-compatible wavelet options", options.size());

            // Log family breakdown for debugging
            if (logger.isDebugEnabled()) {
                int haarCount = swtWavelets.contains(WaveletName.HAAR) ? 1 : 0;
                int daubechiesCount = (int) daubechiesFamily.stream().filter(swtWavelets::contains).count();
                int symletCount = (int) symletFamily.stream().filter(swtWavelets::contains).count();
                int coifletCount = (int) coifletFamily.stream().filter(swtWavelets::contains).count();
                logger.debug("SWT wavelets by family: Haar={}, Daubechies={}, Symlets={}, Coiflets={}",
                           haarCount, daubechiesCount, symletCount, coifletCount);
            }

        } catch (Exception e) {
            logger.error("Error creating SWT wavelet options", e);
        }

        return options;
    }
}
