package com.morphiqlabs.wavelets.swt;

import ai.prophetizo.wavelet.api.TransformType;
import ai.prophetizo.wavelet.api.WaveletName;
import ai.prophetizo.wavelet.api.WaveletRegistry;
import com.morphiqlabs.wavelets.swt.core.Thresholds;
import com.morphiqlabs.wavelets.swt.core.VectorWaveSwtAdapter;
import com.motivewave.platform.sdk.common.*;
import com.motivewave.platform.sdk.common.desc.*;
import com.motivewave.platform.sdk.study.Plot;
import com.motivewave.platform.sdk.study.Study;
import com.motivewave.platform.sdk.study.StudyHeader;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.awt.*;
import java.util.ArrayList;
import java.util.List;

/**
 * SWT Trend + Momentum Study - Advanced trend following with momentum confirmation
 * 
 * This study implements a sophisticated trend-following system using the Stationary Wavelet Transform
 * (SWT/MODWT) with momentum confirmation. Key features include:
 * 
 * - **Trend Extraction**: Uses wavelet approximation (A_J) to identify the dominant trend
 * - **Momentum Calculation**: Aggregates high-frequency detail coefficients (D1, D2) for momentum
 * - **Adaptive Denoising**: BayesShrink thresholding removes noise while preserving signal features
 * - **Auto-Windowing**: Automatically calculates optimal window size based on wavelet properties
 * - **Signal Generation**: Combines trend slope and momentum for high-probability trade signals
 * 
 * Technical Details:
 * - Uses undecimated (redundant) wavelet transform for shift-invariance
 * - Effective support formula: S ≈ 1 + (L-1) * (2^J - 1)
 * - Window size: N = γ * S (γ = safety margin, typically 6.0)
 * - Threshold lookback: M = β * S (β = lookback margin, typically 4.0)
 * 
 * @author Morphiq Labs
 * @version 2.0
 * @since 2024
 */
@StudyHeader(
    namespace = "com.morphiqlabs",
    id = "SWT_TREND_MOMENTUM_SIMPLE",
    name = "SWT Trend + Momentum - SIMPLE",
    desc = "Advanced trend following with SWT/MODWT and momentum confirmation",
    menu = "Morphiq Labs",
    overlay = true,
    signals = true,
    requiresBarUpdates = true,
    helpLink = "https://docs.morphiqlabs.com/swt-trend-momentum"
)
public class SwtTrendMomentumSimple extends Study {
    private static final Logger logger = LoggerFactory.getLogger(SwtTrendMomentumSimple.class);

    // =============================================================================================
    // ENUMS - Type-safe keys following best practices
    // =============================================================================================
    
    /**
     * Value keys for storing calculated values
     * Using enums provides compile-time type safety and prevents typos
     */
    public enum Values {
        TREND,        // Wavelet approximation (A_J) - the smoothed trend
        MOMENTUM,     // Momentum oscillator from detail coefficients
        SLOPE         // Rate of change of trend (ΔA_J)
    }
    
    /**
     * Signal types generated by the study
     */
    public enum Signals {
        LONG,         // Long entry signal
        SHORT         // Short entry signal
    }

    // =============================================================================================
    // CONSTANTS - Settings keys and configuration
    // =============================================================================================
    
    // Core wavelet settings
    private static final String WAVELET_TYPE = "waveletType";
    private static final String DECOMPOSITION_LEVELS = "decompositionLevels";
    private static final String USE_DENOISED = "useDenoised";
    
    // Signal generation settings
    private static final String MOMENTUM_THRESHOLD = "momentumThreshold";
    private static final String MIN_SLOPE_THRESHOLD = "minSlopeThreshold";
    private static final String MOMENTUM_SMOOTHING = "momentumSmoothing";
    private static final String ENABLE_SIGNALS = "enableSignals";
    
    // Window configuration
    private static final String AUTO_WINDOW = "autoWindow";
    private static final String WINDOW_LENGTH = "windowLength";
    private static final String GAMMA_MARGIN = "gammaMargin";
    
    // Threshold lookback configuration
    private static final String AUTO_THRESH_LOOKBACK = "autoThreshLookback";
    private static final String THRESH_LOOKBACK = "threshLookback";
    private static final String BETA_MARGIN = "betaMargin";
    
    // Plot and indicator keys
    private static final String MOMENTUM_PLOT = "momentumPlot";
    private static final String MOMENTUM_IND = "momentumInd";
    private static final String SLOPE_IND = "slopeInd";

    // =============================================================================================
    // DEFAULTS AND LIMITS
    // =============================================================================================
    
    // Wavelet decomposition
    private static final int DEFAULT_LEVELS = 4;
    private static final int MIN_LEVELS = 2;
    private static final int MAX_LEVELS = 8;
    
    // Signal thresholds
    private static final boolean DEFAULT_USE_DENOISED = true;
    private static final double DEFAULT_MOMENTUM_THRESHOLD = 0.1;
    private static final double DEFAULT_MIN_SLOPE = 0.05;  // 0.05 points minimum slope
    private static final double DEFAULT_SMOOTHING = 0.5;   // EMA alpha for momentum
    
    // Window parameters
    private static final boolean DEFAULT_AUTO_WINDOW = true;
    private static final int DEFAULT_WINDOW = 1024;
    private static final int MIN_WINDOW = 256;
    private static final int MAX_WINDOW = 8192;
    private static final double DEFAULT_GAMMA = 6.0;  // Window = gamma * effective_support
    
    // Threshold lookback parameters  
    private static final boolean DEFAULT_AUTO_THRESH_LOOKBACK = true;
    private static final int DEFAULT_THRESH_LOOKBACK = 1024;
    private static final int MIN_THRESH_LOOKBACK = 256;
    private static final int MAX_THRESH_LOOKBACK = 4096;
    private static final double DEFAULT_BETA = 4.0;  // Lookback = beta * effective_support
    
    // Momentum calculation
    private static final int MOMENTUM_LEVELS = 2;  // Use D1 and D2 for momentum

    // =============================================================================================
    // STATE MANAGEMENT
    // =============================================================================================
    
    // Wavelet adapter
    private VectorWaveSwtAdapter swtAdapter;
    
    // Momentum state
    private Double smoothedMomentum = null;  // null = uninitialized, enables proper EMA initialization
    
    // Cache for wavelet type
    private String lastWaveletType = null;

    // =============================================================================================
    // INITIALIZATION - Following Tab → Group → Row pattern
    // =============================================================================================
    
    @Override
    public void initialize(Defaults defaults) {
        logger.debug("Initializing SWT Trend + Momentum Study");
        
        // Create Settings Descriptor
        var sd = createSD();
        
        // ---- General Tab ----
        var generalTab = sd.addTab("General");
        
        // Input configuration
        var inputGroup = generalTab.addGroup("Input");
        inputGroup.addRow(new InputDescriptor(Inputs.INPUT, "Input", Enums.BarInput.CLOSE));
        
        // Wavelet configuration
        var waveletGroup = generalTab.addGroup("Wavelet Configuration");
        waveletGroup.addRow(
            new DiscreteDescriptor(WAVELET_TYPE, "Wavelet Type", "DB4",
                createSWTWaveletOptions())
        );
        waveletGroup.addRow(
            new IntegerDescriptor(DECOMPOSITION_LEVELS, "Decomposition Levels", 
                DEFAULT_LEVELS, MIN_LEVELS, MAX_LEVELS, 1)
        );
        waveletGroup.addRow(
            new BooleanDescriptor(USE_DENOISED, "Use Denoised Signal", DEFAULT_USE_DENOISED)
        );
        
        // Window configuration
        var windowGroup = generalTab.addGroup("Window Configuration");
        windowGroup.addRow(
            new BooleanDescriptor(AUTO_WINDOW, "Auto Window Size", DEFAULT_AUTO_WINDOW)
        );
        windowGroup.addRow(
            new DoubleDescriptor(GAMMA_MARGIN, "Auto Window Margin (γ)", 
                DEFAULT_GAMMA, 2.0, 12.0, 0.5)
        );
        windowGroup.addRow(
            new IntegerDescriptor(WINDOW_LENGTH, "Manual Window (bars)", 
                DEFAULT_WINDOW, MIN_WINDOW, MAX_WINDOW, 64)
        );
        
        // Enable manual window only when auto is disabled
        sd.addDependency(new EnabledDependency(false, AUTO_WINDOW, WINDOW_LENGTH));
        sd.addDependency(new EnabledDependency(true, AUTO_WINDOW, GAMMA_MARGIN));
        
        // ---- Signals Tab ----
        var signalsTab = sd.addTab("Signals");
        
        // Signal configuration
        var signalGroup = signalsTab.addGroup("Signal Generation");
        signalGroup.addRow(
            new BooleanDescriptor(ENABLE_SIGNALS, "Enable Trading Signals", true)
        );
        signalGroup.addRow(
            new DoubleDescriptor(MOMENTUM_THRESHOLD, "Momentum Threshold", 
                DEFAULT_MOMENTUM_THRESHOLD, 0.0, 10.0, 0.01)
        );
        signalGroup.addRow(
            new DoubleDescriptor(MIN_SLOPE_THRESHOLD, "Min Slope (Points)", 
                DEFAULT_MIN_SLOPE, 0.0, 1.0, 0.01)
        );
        signalGroup.addRow(
            new DoubleDescriptor(MOMENTUM_SMOOTHING, "Momentum Smoothing (α)", 
                DEFAULT_SMOOTHING, 0.1, 0.9, 0.05)
        );
        
        // Enable signal settings only when signals are enabled
        sd.addDependency(new EnabledDependency(ENABLE_SIGNALS, 
            MOMENTUM_THRESHOLD, MIN_SLOPE_THRESHOLD, MOMENTUM_SMOOTHING));
        
        // ---- Advanced Tab ----
        var advancedTab = sd.addTab("Advanced");
        
        // Threshold lookback configuration
        var thresholdGroup = advancedTab.addGroup("Threshold Lookback");
        thresholdGroup.addRow(
            new BooleanDescriptor(AUTO_THRESH_LOOKBACK, "Auto Lookback", DEFAULT_AUTO_THRESH_LOOKBACK)
        );
        thresholdGroup.addRow(
            new DoubleDescriptor(BETA_MARGIN, "Auto Lookback Margin (β)", 
                DEFAULT_BETA, 2.0, 12.0, 0.5)
        );
        thresholdGroup.addRow(
            new IntegerDescriptor(THRESH_LOOKBACK, "Manual Lookback (bars)", 
                DEFAULT_THRESH_LOOKBACK, MIN_THRESH_LOOKBACK, MAX_THRESH_LOOKBACK, 64)
        );
        
        // Enable manual lookback only when auto is disabled
        sd.addDependency(new EnabledDependency(false, AUTO_THRESH_LOOKBACK, THRESH_LOOKBACK));
        sd.addDependency(new EnabledDependency(true, AUTO_THRESH_LOOKBACK, BETA_MARGIN));
        
        // ---- Display Tab ----
        var displayTab = sd.addTab("Display");
        
        // Path configuration
        var pathsGroup = displayTab.addGroup("Paths");
        pathsGroup.addRow(
            new PathDescriptor(Inputs.PATH, "Trend Line", 
                defaults.getBlue(), 2.0f, null, true, true, true)
        );
        pathsGroup.addRow(
            new PathDescriptor(Inputs.PATH2, "Momentum", 
                Color.CYAN, 1.5f, null, true, true, false)
        );
        pathsGroup.addRow(
            new PathDescriptor(Inputs.PATH3, "Slope", 
                defaults.getYellow(), 1.0f, null, false, true, false)
        );
        
        // Indicator configuration
        var indicatorGroup = displayTab.addGroup("Indicators");
        indicatorGroup.addRow(
            new IndicatorDescriptor(Inputs.IND, "Trend", null, null, false, true, true)
        );
        indicatorGroup.addRow(
            new IndicatorDescriptor(MOMENTUM_IND, "Momentum", Color.CYAN, null, false, false, true)
        );
        indicatorGroup.addRow(
            new IndicatorDescriptor(SLOPE_IND, "Slope", defaults.getYellow(), null, false, false, true)
        );
        
        // ---- Markers Tab ----
        var markersTab = sd.addTab("Markers");
        var markersGroup = markersTab.addGroup("Signal Markers");
        markersGroup.addRow(
            new MarkerDescriptor(Signals.LONG.name(), "Long Signal",
                Enums.MarkerType.TRIANGLE, Enums.Size.MEDIUM, 
                defaults.getGreen(), defaults.getLineColor(), true, true)
        );
        markersGroup.addRow(
            new MarkerDescriptor(Signals.SHORT.name(), "Short Signal",
                Enums.MarkerType.TRIANGLE, Enums.Size.MEDIUM, 
                defaults.getRed(), defaults.getLineColor(), true, true)
        );
        
        // Create Runtime Descriptor
        var desc = createRD();
        
        // Configure label generation
        desc.setLabelSettings(WAVELET_TYPE, DECOMPOSITION_LEVELS);
        
        // Export values for external access
        desc.exportValue(new ValueDescriptor(Values.TREND, "SWT Trend", 
            new String[]{WAVELET_TYPE, DECOMPOSITION_LEVELS}));
        desc.exportValue(new ValueDescriptor(Values.MOMENTUM, "Momentum", 
            new String[]{DECOMPOSITION_LEVELS}));
        desc.exportValue(new ValueDescriptor(Values.SLOPE, "Slope", new String[]{}));
        
        // Main plot configuration (overlay on price)
        desc.declarePath(Values.TREND, Inputs.PATH);
        desc.declareIndicator(Values.TREND, Inputs.IND);
        desc.setRangeKeys(Values.TREND);
        
        // Momentum plot (separate pane)
        Plot momentumPlot = new Plot();
        desc.addPlot(MOMENTUM_PLOT, momentumPlot);
        momentumPlot.setLabelSettings("Momentum");
        momentumPlot.setTabName("Momentum");
        momentumPlot.declarePath(Values.MOMENTUM, Inputs.PATH2);
        momentumPlot.declarePath(Values.SLOPE, Inputs.PATH3);
        momentumPlot.declareIndicator(Values.MOMENTUM, MOMENTUM_IND);
        momentumPlot.declareIndicator(Values.SLOPE, SLOPE_IND);
        momentumPlot.setRangeKeys(Values.MOMENTUM, Values.SLOPE);
        momentumPlot.addHorizontalLine(new LineInfo(0.0, null, 1.0f, new float[]{3, 3}));
        
        // Signal declarations
        desc.declareSignal(Signals.LONG, "Long Signal");
        desc.declareSignal(Signals.SHORT, "Short Signal");
        
        setRuntimeDescriptor(desc);
    }

    // =============================================================================================
    // LIFECYCLE METHODS
    // =============================================================================================
    
    @Override
    public void onLoad(Defaults defaults) {
        try {
            // Initialize wavelet adapter with current settings
            initializeAdapter();
            
            if (swtAdapter == null) {
                // Try fallback initialization
                swtAdapter = new VectorWaveSwtAdapter("db4");
                lastWaveletType = "db4";
            }
            
            // Set minimum bars based on current settings
            int minBars = calculateCurrentWindowLength();
            setMinBars(minBars);
            
            if (logger.isDebugEnabled()) {
                logger.debug("onLoad: Initialized with wavelet={}, minBars={}", 
                            lastWaveletType, minBars);
            }
            
        } catch (Exception e) {
            // Ensure we have at least a basic adapter
            if (swtAdapter == null) {
                swtAdapter = new VectorWaveSwtAdapter("db4");
                lastWaveletType = "db4";
            }
            setMinBars(DEFAULT_WINDOW);
            if (logger.isDebugEnabled()) {
                logger.debug("onLoad: Error during initialization, using defaults", e);
            }
        }
    }
    
    @Override
    public void onSettingsUpdated(DataContext ctx) {
        logger.debug("onSettingsUpdated: Clearing state for recalculation");
        
        // Clear cached state and force adapter reinitialization
        clearState();
        
        // Force wavelet type check on next calculation
        lastWaveletType = null;
        swtAdapter = null;
        
        // Update minimum bars
        setMinBars(calculateCurrentWindowLength());
        
        // Mark all bars for recalculation and clear values to force range recalculation
        DataSeries series = ctx.getDataSeries();
        if (series != null) {
            // Clear all calculated values to ensure complete recalculation and range update
            for (int i = 0; i < series.size(); i++) {
                series.setComplete(i, false);
                // Clear all values - this forces MotiveWave to recalculate plot ranges
                series.setDouble(i, Values.TREND, null);
                series.setDouble(i, Values.MOMENTUM, null);
                series.setDouble(i, Values.SLOPE, null);
            }
        }
        
        // Call parent implementation
        super.onSettingsUpdated(ctx);
    }
    
    @Override
    public void clearState() {
        if (logger.isDebugEnabled()) {
            logger.debug("clearState: Resetting internal state");
        }
        super.clearState();
        
        // Reset adapter and state
        swtAdapter = null;
        smoothedMomentum = null;
        lastWaveletType = null;
    }
    
    @Override
    public int getMinBars() {
        // Return minimum bars needed based on window configuration
        return calculateCurrentWindowLength() + 10;  // Add buffer for slope calculation
    }

    // =============================================================================================
    // CALCULATION - Core wavelet processing
    // =============================================================================================
    
    @Override
    protected void calculateValues(DataContext ctx) {
        DataSeries series = ctx.getDataSeries();
        if (series == null) return;
        
        int size = series.size();
        if (size == 0) return;
        
        // Find the first incomplete bar to start processing
        int startIndex = size - 1;
        for (int i = size - 1; i >= 0; i--) {
            if (!series.isComplete(i)) {
                startIndex = i;
            } else {
                // Found a complete bar, can stop looking backwards
                break;
            }
        }
        
        // Process only incomplete bars starting from the first one found
        for (int i = startIndex; i < size; i++) {
            if (!series.isComplete(i)) {
                calculate(i, ctx);
            }
        }
    }
    
    @Override
    protected void calculate(int index, DataContext ctx) {
        DataSeries series = ctx.getDataSeries();
        if (series == null || series.size() == 0) {
            return;
        }
        
        // Skip if already complete (avoid recalculation)
        if (series.isComplete(index)) {
            return;
        }
        
        // Check if wavelet type has changed
        String currentWaveletType = getSettings().getString(WAVELET_TYPE, "db4");
        if (!currentWaveletType.equals(lastWaveletType)) {
            // Wavelet type changed, force complete reinitialization
            logger.info("Wavelet type changed from {} to {}, forcing reinitialization", 
                       lastWaveletType, currentWaveletType);
            swtAdapter = null;  // Clear old adapter
            lastWaveletType = null;  // Force recreation
            smoothedMomentum = null;  // Reset momentum state
            initializeAdapter();
        }
        
        // Ensure adapter is initialized
        if (swtAdapter == null) {
            initializeAdapter();
            if (swtAdapter == null) {
                // Fallback initialization
                swtAdapter = new VectorWaveSwtAdapter("db4");
                lastWaveletType = "db4";
            }
        }
        
        // Get current settings
        int levels = getSettings().getInteger(DECOMPOSITION_LEVELS, DEFAULT_LEVELS);
        boolean useDenoised = getSettings().getBoolean(USE_DENOISED, DEFAULT_USE_DENOISED);
        boolean enableSignals = getSettings().getBoolean(ENABLE_SIGNALS, true);
        Object input = getSettings().getInput(Inputs.INPUT);
        
        // Calculate window parameters
        int windowLength = calculateCurrentWindowLength();
        int threshLookback = calculateCurrentThresholdLookback(levels);
        
        // Check if we have enough data
        if (index < windowLength - 1) {
            clearValues(series, index);
            return;
        }
        
        // Get sliding window of data
        double[] data = getWindowData(series, index, windowLength, input);
        if (data == null || data.length < windowLength) {
            clearValues(series, index);
            return;
        }
        
        // Log parameters only once
        if (index == windowLength - 1 && logger.isDebugEnabled()) {
            logCalculationParameters(levels, windowLength, threshLookback);
        }
        
        try {
            // Perform SWT/MODWT transform
            VectorWaveSwtAdapter.SwtResult swtResult = swtAdapter.transform(data, levels);
            if (swtResult == null) {
                clearValues(series, index);
                return;
            }
            
            // Log transform details on first few bars for debugging
            if (index < windowLength + 5 && logger.isDebugEnabled()) {
                double[] approx = swtResult.getApproximation();
                logger.debug("Transform at index {} with {}: approx length={}, last value={}",
                           index, swtResult.getWaveletType(), 
                           approx != null ? approx.length : 0,
                           approx != null && approx.length > 0 ? approx[approx.length - 1] : "null");
            }
            
            // Calculate momentum from detail coefficients
            double rawMom = calculateRawMomentum(swtResult);
            double momentum = smoothMomentum(rawMom);
            series.setDouble(index, Values.MOMENTUM, momentum);
            
            // Apply denoising if enabled
            if (useDenoised) {
                applyBayesShrinkDenoising(swtResult, threshLookback);
            }
            
            // Extract trend value
            double currentTrend = extractTrendValue(swtResult, useDenoised, levels);
            series.setDouble(index, Values.TREND, currentTrend);
            
            // Calculate slope
            double slope = 0.0;
            if (index > 0) {
                Double prevTrend = series.getDouble(index - 1, Values.TREND);
                if (prevTrend != null) {
                    slope = currentTrend - prevTrend;
                    series.setDouble(index, Values.SLOPE, slope);
                    
                    // Generate signals if enabled
                    if (enableSignals) {
                        generateSignals(ctx, series, index, momentum, slope);
                    }
                }
            }
            
            // Mark as complete
            series.setComplete(index);
            
        } catch (Exception e) {
            logger.error("calculate: Error at index {}", index, e);
            clearValues(series, index);
        }
    }
    
    /**
     * Clear all values for a given index
     */
    private void clearValues(DataSeries series, int index) {
        series.setDouble(index, Values.TREND, null);
        series.setDouble(index, Values.MOMENTUM, null);
        series.setDouble(index, Values.SLOPE, null);
    }
    
    /**
     * Get sliding window of input data
     */
    private double[] getWindowData(DataSeries series, int index, int windowLength, Object input) {
        if (series == null || windowLength <= 0) {
            return null;
        }
        
        double[] window = new double[windowLength];
        int start = index - windowLength + 1;
        
        // Track if we have valid data
        boolean hasValidData = false;
        
        for (int i = 0; i < windowLength; i++) {
            int dataIndex = start + i;
            if (dataIndex < 0 || dataIndex >= series.size()) {
                // Use first/last available value for padding
                window[i] = (dataIndex < 0) ? series.getClose(0) : series.getClose(series.size() - 1);
                continue;
            }
            
            Double value = series.getDouble(dataIndex, input);
            if (value != null) {
                window[i] = value;
                hasValidData = true;
            } else {
                // Fallback to close price
                window[i] = series.getClose(dataIndex);
                if (window[i] != 0.0) {
                    hasValidData = true;
                }
            }
        }
        
        if (!hasValidData) {
            return null;
        }
        
        return window;
    }
    
    /**
     * Calculate raw momentum from detail coefficients
     */
    private double calculateRawMomentum(VectorWaveSwtAdapter.SwtResult swtResult) {
        int levelsToUse = Math.min(MOMENTUM_LEVELS, swtResult.getLevels());
        double momentum = 0.0;
        
        // Sum last coefficients from D1 and D2 (high-frequency components)
        for (int level = 1; level <= levelsToUse; level++) {
            double[] detail = swtResult.getDetail(level);
            if (detail != null && detail.length > 0) {
                momentum += detail[detail.length - 1];
            }
        }
        
        return momentum;
    }
    
    /**
     * Apply exponential smoothing to momentum
     */
    private double smoothMomentum(double newValue) {
        double alpha = getSettings().getDouble(MOMENTUM_SMOOTHING, DEFAULT_SMOOTHING);
        
        // Initialize on first value
        if (smoothedMomentum == null) {
            smoothedMomentum = newValue;
        } else {
            // EMA formula: smoothed = α * new + (1 - α) * previous
            smoothedMomentum = alpha * newValue + (1.0 - alpha) * smoothedMomentum;
        }
        
        return smoothedMomentum;
    }
    
    /**
     * Apply BayesShrink denoising to detail coefficients
     */
    private void applyBayesShrinkDenoising(VectorWaveSwtAdapter.SwtResult swtResult, int lookback) {
        // Apply threshold to each detail level
        for (int level = 1; level <= swtResult.getLevels(); level++) {
            double[] detail = swtResult.getDetail(level);
            if (detail == null || detail.length == 0) continue;
            
            // Use last M samples to estimate threshold
            int m = Math.min(lookback, detail.length);
            int start = detail.length - m;
            double[] tail = new double[m];
            System.arraycopy(detail, start, tail, 0, m);
            
            // Calculate BayesShrink threshold
            double threshold = Thresholds.calculateThreshold(
                tail, Thresholds.ThresholdMethod.BAYES, level);
            
            // Apply soft thresholding
            swtResult.applyShrinkage(level, threshold, true);
        }
    }
    
    /**
     * Extract trend value from SWT result
     */
    private double extractTrendValue(VectorWaveSwtAdapter.SwtResult swtResult, 
                                     boolean useDenoised, int levels) {
        if (useDenoised) {
            // Reconstruct denoised signal from thresholded coefficients
            double[] reconstructed = swtResult.reconstruct(levels);
            if (reconstructed != null && reconstructed.length > 0) {
                double value = reconstructed[reconstructed.length - 1];
                if (logger.isTraceEnabled()) {
                    logger.trace("Denoised trend value: {}", value);
                }
                return value;
            }
        } else {
            // Use raw approximation coefficients
            double[] approx = swtResult.getApproximation();
            if (approx != null && approx.length > 0) {
                double value = approx[approx.length - 1];
                // Log the actual approximation value being used
                if (logger.isDebugEnabled()) {
                    logger.debug("Extracted trend from {}: A[{}]={}, first 3=[{}, {}, {}]",
                               swtResult.getWaveletType(), approx.length - 1, value,
                               approx.length > 0 ? approx[0] : "N/A",
                               approx.length > 1 ? approx[1] : "N/A", 
                               approx.length > 2 ? approx[2] : "N/A");
                }
                return value;
            }
        }
        
        logger.warn("Failed to extract trend value, returning 0.0");
        return 0.0;  // Fallback
    }
    
    /**
     * Generate trading signals based on momentum and slope
     */
    private void generateSignals(DataContext ctx, DataSeries series, int index, 
                                 double momentum, double slope) {
        double momentumThreshold = getSettings().getDouble(MOMENTUM_THRESHOLD, DEFAULT_MOMENTUM_THRESHOLD);
        double minSlope = getSettings().getDouble(MIN_SLOPE_THRESHOLD, DEFAULT_MIN_SLOPE);
        
        // Long signal: positive momentum and upward slope
        if (momentum > momentumThreshold && slope > minSlope) {
            MarkerInfo marker = getSettings().getMarker(Signals.LONG.name());
            if (marker != null && marker.isEnabled()) {
                ctx.signal(index, Signals.LONG, "Long Signal", series.getClose(index));
                series.setBoolean(index, Signals.LONG, true);
            }
        }
        
        // Short signal: negative momentum and downward slope
        if (momentum < -momentumThreshold && slope < -minSlope) {
            MarkerInfo marker = getSettings().getMarker(Signals.SHORT.name());
            if (marker != null && marker.isEnabled()) {
                ctx.signal(index, Signals.SHORT, "Short Signal", series.getClose(index));
                series.setBoolean(index, Signals.SHORT, true);
            }
        }
    }
    
    /**
     * Log calculation parameters for debugging
     */
    private void logCalculationParameters(int levels, int windowLength, int threshLookback) {
        if (!logger.isDebugEnabled()) return;
        
        String waveletType = getSettings().getString(WAVELET_TYPE, "db4");
        int filterLength = getFilterLength();
        int support = calculateEffectiveSupport(filterLength, levels);
        boolean useDenoised = getSettings().getBoolean(USE_DENOISED, DEFAULT_USE_DENOISED);
        
        logger.debug("SWT Parameters: wavelet={}, filterLength={}, levels={}, " +
                    "effectiveSupport={}, window={}, threshLookback={}, denoised={}",
                    waveletType, filterLength, levels, support, 
                    windowLength, threshLookback, useDenoised);
    }

    // =============================================================================================
    // WAVELET CONFIGURATION HELPERS
    // =============================================================================================
    
    /**
     * Initialize or reinitialize the SWT adapter
     */
    private void initializeAdapter() {
        String waveletType = getSettings().getString(WAVELET_TYPE, "DB4");
        
        // Verify wavelet is compatible with SWT
        if (!verifyWaveletCompatibility(waveletType)) {
            logger.warn("Wavelet {} not compatible with SWT, using fallback DB4", waveletType);
            waveletType = "DB4";
        }
        
        // Always create a new adapter to ensure wavelet is properly set
        try {
            logger.info("Creating new SWT adapter with wavelet: {} (was: {})", 
                       waveletType, lastWaveletType);
            
            // Create completely new adapter
            VectorWaveSwtAdapter newAdapter = new VectorWaveSwtAdapter(waveletType);
            
            // More comprehensive test with longer signal that works for all wavelets
            double[] testData = new double[64];
            for (int i = 0; i < testData.length; i++) {
                testData[i] = Math.sin(2 * Math.PI * i / 16.0) + i * 0.1;
            }
            
            VectorWaveSwtAdapter.SwtResult testResult = newAdapter.transform(testData, 2);
            if (testResult == null) {
                throw new RuntimeException("Adapter test failed - null result");
            }
            
            // Verify we got different results for different wavelets
            double[] testDetail = testResult.getDetail(1);
            double[] testApprox = testResult.getApproximation();
            if (testDetail != null && testDetail.length > 0 && testApprox != null && testApprox.length > 0) {
                logger.info("Test transform for {}: D1[0]={}, D1[last]={}, A[0]={}, A[last]={}", 
                           waveletType, testDetail[0], testDetail[testDetail.length - 1],
                           testApprox[0], testApprox[testApprox.length - 1]);
                
                // If we have a previous wavelet type, compare the results
                if (lastWaveletType != null && !lastWaveletType.equals(waveletType)) {
                    logger.info("Wavelet switch confirmed: {} -> {}, expecting different approximation values",
                               lastWaveletType, waveletType);
                }
            }
            
            // If test passes, use the new adapter
            swtAdapter = newAdapter;
            lastWaveletType = waveletType;
            logger.info("Successfully initialized SWT adapter with wavelet: {}", waveletType);
                
            } catch (Exception e) {
                logger.error("Failed to initialize SWT adapter with wavelet: {}", waveletType, e);
                
                // Try fallback wavelets
                String[] fallbacks = {"db4", "haar", "db6"};
                for (String fallback : fallbacks) {
                    if (!fallback.equals(waveletType)) {
                        try {
                            if (logger.isDebugEnabled()) {
                                logger.debug("Trying fallback wavelet: {}", fallback);
                            }
                            swtAdapter = new VectorWaveSwtAdapter(fallback);
                            lastWaveletType = fallback;
                            if (logger.isDebugEnabled()) {
                                logger.debug("Successfully initialized with fallback wavelet: {}", fallback);
                            }
                            break;
                        } catch (Exception fe) {
                            logger.error("Fallback wavelet {} also failed", fallback, fe);
                        }
                    }
                }
                
                // If all fallbacks fail, ensure we have something
                if (swtAdapter == null) {
                    logger.error("All wavelet initializations failed, using final fallback");
                    swtAdapter = new VectorWaveSwtAdapter("db4");
                    lastWaveletType = "db4";
                }
            }
    }
    
    /**
     * Get filter length for current wavelet
     */
    private int getFilterLength() {
        if (swtAdapter != null) {
            try {
                int length = swtAdapter.getFilterLength();
                if (length > 0) return length;
            } catch (Exception e) {
                logger.debug("Could not get filter length from adapter", e);
            }
        }
        
        // Fallback to known values
        String waveletType = getSettings().getString(WAVELET_TYPE, "db4");
        return switch (waveletType.toLowerCase()) {
            case "haar" -> 2;
            case "db6" -> 12;
            case "db4" -> 8;
            default -> 8;
        };
    }
    
    /**
     * Calculate effective support for undecimated wavelet transform
     * Support ≈ 1 + (L - 1) * (2^J - 1)
     */
    private int calculateEffectiveSupport(int filterLength, int levels) {
        return 1 + (filterLength - 1) * ((1 << levels) - 1);
    }
    
    /**
     * Calculate current window length based on settings
     */
    private int calculateCurrentWindowLength() {
        Settings settings = getSettings();
        boolean autoWindow = settings.getBoolean(AUTO_WINDOW, DEFAULT_AUTO_WINDOW);
        
        if (autoWindow) {
            int levels = settings.getInteger(DECOMPOSITION_LEVELS, DEFAULT_LEVELS);
            double gamma = settings.getDouble(GAMMA_MARGIN, DEFAULT_GAMMA);
            int filterLength = getFilterLength();
            int support = calculateEffectiveSupport(filterLength, levels);
            int windowLength = (int) Math.ceil(gamma * support);
            
            // Round up to nearest 64 for cache efficiency
            windowLength = ((windowLength + 63) / 64) * 64;
            
            // Clamp to valid range
            return Math.max(MIN_WINDOW, Math.min(MAX_WINDOW, windowLength));
        }
        
        return settings.getInteger(WINDOW_LENGTH, DEFAULT_WINDOW);
    }
    
    /**
     * Calculate current threshold lookback based on settings
     */
    private int calculateCurrentThresholdLookback(int levels) {
        Settings settings = getSettings();
        boolean autoLookback = settings.getBoolean(AUTO_THRESH_LOOKBACK, DEFAULT_AUTO_THRESH_LOOKBACK);
        
        if (autoLookback) {
            double beta = settings.getDouble(BETA_MARGIN, DEFAULT_BETA);
            int filterLength = getFilterLength();
            int support = calculateEffectiveSupport(filterLength, levels);
            int lookback = (int) Math.ceil(beta * support);
            
            // Round up to nearest 64
            lookback = ((lookback + 63) / 64) * 64;
            
            // Clamp to valid range
            return Math.max(MIN_THRESH_LOOKBACK, Math.min(MAX_THRESH_LOOKBACK, lookback));
        }
        
        return settings.getInteger(THRESH_LOOKBACK, DEFAULT_THRESH_LOOKBACK);
    }
    
    // =============================================================================================
    // UI HELPERS
    // =============================================================================================
    
    /**
     * Create wavelet options for UI dropdown - only SWT-compatible wavelets
     * Uses the new VectorWave API to get wavelets specifically compatible with SWT
     */
    private List<NVP> createSWTWaveletOptions() {
        List<NVP> options = new ArrayList<>();
        
        try {
            // Get wavelets specifically compatible with SWT transform
            List<WaveletName> swtWavelets = WaveletRegistry.getWaveletsForTransform(TransformType.SWT);
            
            // Use the new family-specific API methods for better organization
            // Get wavelets by family and filter for SWT compatibility
            List<WaveletName> daubechiesFamily = WaveletRegistry.getDaubechiesWavelets();
            List<WaveletName> symletFamily = WaveletRegistry.getSymletWavelets();
            List<WaveletName> coifletFamily = WaveletRegistry.getCoifletWavelets();
            
            // Add wavelets in family groups for better UI organization
            // Start with Haar (simplest) - always compatible with SWT
            if (swtWavelets.contains(WaveletName.HAAR)) {
                options.add(new NVP("Haar", WaveletName.HAAR.name()));
            }
            
            // Then Daubechies (most common) - only add if SWT compatible
            for (WaveletName wavelet : daubechiesFamily) {
                if (swtWavelets.contains(wavelet)) {
                    options.add(new NVP(wavelet.getDescription(), wavelet.name()));
                }
            }
            
            // Then Symlets - only add if SWT compatible
            for (WaveletName wavelet : symletFamily) {
                if (swtWavelets.contains(wavelet)) {
                    options.add(new NVP(wavelet.getDescription(), wavelet.name()));
                }
            }
            
            // Finally Coiflets - only add if SWT compatible
            for (WaveletName wavelet : coifletFamily) {
                if (swtWavelets.contains(wavelet)) {
                    options.add(new NVP(wavelet.getDescription(), wavelet.name()));
                }
            }
            
            logger.info("Created {} SWT-compatible wavelet options", options.size());
            
            // Log family breakdown for debugging
            if (logger.isDebugEnabled()) {
                int haarCount = swtWavelets.contains(WaveletName.HAAR) ? 1 : 0;
                int daubechiesCount = (int) daubechiesFamily.stream().filter(swtWavelets::contains).count();
                int symletCount = (int) symletFamily.stream().filter(swtWavelets::contains).count();
                int coifletCount = (int) coifletFamily.stream().filter(swtWavelets::contains).count();
                logger.debug("SWT wavelets by family: Haar={}, Daubechies={}, Symlets={}, Coiflets={}",
                           haarCount, daubechiesCount, symletCount, coifletCount);
            }
            
        } catch (Exception e) {
            logger.error("Error creating SWT wavelet options", e);
        }
        
        return options;
    }
    
    /**
     * Verify wavelet compatibility with SWT before initialization
     * This ensures we only use wavelets that are guaranteed to work with SWT
     */
    private boolean verifyWaveletCompatibility(String waveletName) {
        try {
            WaveletName wavelet = WaveletName.valueOf(waveletName.toUpperCase());
            boolean compatible = WaveletRegistry.isCompatible(wavelet, TransformType.SWT);
            
            if (!compatible) {
                logger.warn("Wavelet {} is not compatible with SWT transform", waveletName);
            }
            
            return compatible;
        } catch (Exception e) {
            logger.error("Error verifying wavelet compatibility: {}", waveletName, e);
            return false;
        }
    }
}